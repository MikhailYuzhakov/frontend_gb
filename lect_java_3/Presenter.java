public class Presenter {
    public static void main(String[] args) {

    }
    /*
    ООП
    Класс - это шаблон (чертеж) и это новый тип данных.
    new - динамически выделяет память на объект.
    методы формируют API класса
    Статика (модификатор) делает метод независит от объекта.
    Статические методы - методы класса, а не объекта.

    Память = куча + стек
    Стек (LIFO).
    Программа имеет область видимости, например программа для метода видит только
    ту память которая для него. То же для потоков.
    Все примитивные типы данных целиком хранятся в стеке.

    Особенности стека:
    - заполняется и освобождается по мере вызова и завершения новых методов.
    - перменные на стеке существуют до тех пор, пока выполняется метод в
    котором они были созданы;
    - если память будет заполнена, java бросит исключение java.lang.StackOverflowError
    - доступ к стеку осуществляется быстрее, чем к куче
    - является потокобезоопассным, поскольку для каждого потока создается свой отдельный стек.

    Поколения кучи:
    1. Young Generation
     попадают в eden space - тут происходит "незначительная сборка мусора"
     те, что отмечены сборщиком мусора удаляются и отсавшиеся перемещаются в survivor space и так далее циклически
     (S0, S1, S2 ... survivor space).
     любые объекты попавшие в область выживших помечаются меткой возраста.
    2. Old Generation
     через несколько циклов сборки мусора, то объекты переходят в "старшее поколение" - тут проходит тщательная
     сборка мусора.
    3. Permanent Generation (упрощен в Java 8) - тут живут статические поля


    Особенности кучи:
    - в общем случае, размеры кучи на порядок больше размеров стека;
    - когда куча полностью заполняется, Java бросает исключение java.lang.OutOfMemoryError;
    - доступ к ней медленнее, чем к стеку;
    - куча в отличии от стека, автоматически не освобождается. Для сбора неиспользуемых обхектов используется сборщик
     мусора.
    - в отличии от стека, куча не является потокобезопасной, поскольку для всех одна, и ее необходимо контролировать,
      правильно синхронизирую ход.

     Процесс сборки мусора:
     Процесс запускается автоматические Java и Java решается запускать или нет этот процесс.
     Можем явно вызвать системный сборщик мусора - но это не рекомендуется.
     Процесс - отмечай и подметай. ЯП подмечает неиспользуемый процессы и объекты.
     При сборке мусора все процессы останавливаются.
     Сборщики мусора: последотельный алгоритм, параллельный сборщик (по умолчанию), CMS (count max sweep) использует
     несколько потоков сборки мусора с минимальными паузами, G1 (garbage first) для многопроцесоррных ПК, ZGC сборщик
      с меньшей задержкой (Java 15), не останавливает рабооту на период > 10 vc/

      Итого по куче:
      - куча доступна везде, объекты доступны отовсюду;
      - все объекты хранятся в куче, все локальные переменные хранятся на стеке;
      - стек недолговечен;
      - и стек и куча могут быть переполнены;
      - куча много больше стека, но стек гораздо быстрее.
     */
}
